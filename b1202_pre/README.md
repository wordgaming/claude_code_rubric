# 部分可观察性迷宫求解器 - C# 控制台应用

## 概述

这是一个增强版的迷宫求解器，实现了**部分可观察性**和**战争迷雾机制**。与原始版本不同，求解器在开始时无法访问完整的迷宫布局，而是必须通过探索逐步构建地图。代理只能"看到"其相邻的单元格（上、下、左、右），并在移动时逐渐发现迷宫的结构。

## 核心特性

### 1. 部分可观察性
- 代理在开始时不知道完整的迷宫布局
- 只能感知当前位置的相邻单元格
- 必须基于已发现的信息做出移动决策
- 不能依赖完整的迷宫数据结构

### 2. 战争迷雾机制
- 未探索的区域在渲染时显示为迷雾（░符号）
- 已探索的区域显示实际的墙壁和路径
- 渲染输出反映代理的记忆和知识
- 可视化显示已访问路径、发现的死胡同和未探索区域

### 3. 动态地图构建
- 使用内部数据结构跟踪已知空间与未知空间
- 在探索过程中动态更新内部地图
- 记录哪些墙壁已被扫描，哪些单元格已被访问

### 4. DFS求解逻辑
- 使用深度优先搜索算法
- 仅基于已发现的信息进行决策
- 在受限视野下仍能找到从起点到终点的路径

## 文件结构

```
c/claude/
├── Cell.cs                          # 单元格类（增强版）
├── Maze.cs                          # 迷宫生成器
├── PartialObservabilitySolver.cs   # 部分可观察性求解器
├── PartialRenderer.cs               # 战争迷雾渲染器
├── Program.cs                       # 主程序入口
└── README.md                        # 本文档
```

## 文件说明

### [`Cell.cs`](c/claude/Cell.cs:1)
增强的单元格类，添加了以下属性：
- `Explored`: 标记单元格是否已被探索
- `WallsKnown`: 数组，标记每面墙是否已知

### [`Maze.cs`](c/claude/Maze.cs:1)
与原始版本相同，使用递归回溯算法生成完美迷宫。

### [`PartialObservabilitySolver.cs`](c/claude/PartialObservabilitySolver.cs:1)
核心求解器，实现了：
- **ScanCell()**: 扫描当前位置的相邻单元格，更新内部地图
- **DFS()**: 深度优先搜索，仅使用已知信息进行决策
- **内部地图**: 使用Dictionary存储已发现的单元格信息

关键实现细节：
```csharp
// 内部地图结构
private Dictionary<(int, int), KnownCell> knownMap;

// 扫描当前单元格
private void ScanCell(Cell cell)
{
    // 标记当前单元格为已探索
    cell.Explored = true;
    
    // 扫描四个方向的墙壁
    // 更新内部地图
}

// DFS只使用已知信息
private bool DFS(Cell cell, HashSet<(int, int)> visited)
{
    // 扫描当前位置
    ScanCell(cell);
    
    // 只在已知没有墙的方向移动
    if (known.WallsKnown[wall] && !known.Walls[wall])
    {
        // 移动到相邻单元格
    }
}
```

### [`PartialRenderer.cs`](c/claude/PartialRenderer.cs:1)
实现战争迷雾渲染：
- **PrintMaze()**: 渲染带迷雾的迷宫，未探索区域显示为░
- **PrintFullMaze()**: 渲染完整迷宫（用于对比）
- **PrintStatistics()**: 显示探索统计信息

渲染符号：
- `S` - 起点
- `E` - 终点
- `?` - 解决路径
- `·` - 已访问但不在路径上
- `#` - 墙壁
- `░` - 未探索区域（迷雾）

### [`Program.cs`](c/claude/Program.cs:1)
主程序流程：
1. 获取用户输入的迷宫尺寸
2. 生成迷宫
3. 显示完整迷宫（参考）
4. 使用部分可观察性求解器求解
5. 显示带战争迷雾的求解结果
6. 显示探索统计
7. 再次显示完整迷宫以便对比

## 运行方法

### 方法1: 使用 .NET SDK

```bash
cd c/claude
dotnet run
```

### 方法2: 手动编译

```bash
cd c/claude
csc *.cs
Program.exe
```

### 方法3: Visual Studio

1. 在 Visual Studio 中打开文件夹
2. 创建新的控制台应用项目
3. 添加所有 .cs 文件
4. 运行项目

## 使用说明

1. 运行程序后，输入迷宫的宽度和高度（例如：10 x 10）
2. 程序首先显示完整迷宫作为参考
3. 按任意键开始部分可观察性求解
4. 查看带战争迷雾的求解结果
5. 查看探索统计信息
6. 对比完整迷宫和探索结果

## 实现亮点

### 1. 真正的部分可观察性
求解器不访问完整的迷宫数据，而是：
- 维护独立的内部地图
- 只在扫描时更新已知信息
- 决策完全基于已发现的信息

### 2. 渐进式地图构建
```csharp
// 代理逐步构建地图
if (!knownMap.ContainsKey((x, y)))
{
    knownMap[(x, y)] = new KnownCell();
}
```

### 3. 视觉化战争迷雾
未探索区域清晰地显示为迷雾，让用户直观看到代理的探索过程。

### 4. 探索效率统计
程序显示：
- 总单元格数
- 已探索单元格数和百分比
- 已访问单元格数和百分比
- 路径单元格数和百分比

## 与原始版本的对比

| 特性 | 原始版本 | 部分可观察性版本 |
|------|---------|-----------------|
| 地图访问 | 完整访问 | 仅已探索区域 |
| 决策依据 | 完整迷宫信息 | 已发现信息 |
| 渲染 | 显示所有墙壁 | 显示战争迷雾 |
| 数据结构 | 直接使用Maze.Grid | 维护独立的knownMap |
| 探索过程 | 不可见 | 可视化显示 |

## 技术细节

### 扫描机制
每次代理到达一个新位置时：
1. 标记当前单元格为已探索
2. 扫描四个方向的墙壁
3. 更新内部地图
4. 标记相邻可达单元格的存在

### 决策机制
代理只能：
- 移动到已知没有墙的方向
- 访问尚未访问过的单元格
- 基于DFS策略选择下一步

### 内存管理
使用 `Dictionary<(int, int), KnownCell>` 存储已知信息：
- 键：单元格坐标 (x, y)
- 值：已知的墙壁信息和访问状态

## 示例输出

```
=== 部分可观察性迷宫 (战争迷雾) ===
图例: S=起点 E=终点 ?=路径 ░=未探索 #=墙壁

## # ░░░░░░░░
#S ?#░░░░░░░░
## ?#░░░░░░░░
# ??#░░░░░░░░
...

=== 探索统计 ===
总单元格数: 100
已探索单元格: 45 (45.0%)
已访问单元格: 23 (23.0%)
路径单元格: 15 (15.0%)
```

## 扩展可能性

1. **动画演示**: 逐步显示探索过程
2. **多种算法**: 实现BFS、A*等算法的部分可观察性版本
3. **传感器范围**: 调整可见范围（例如：2格距离）
4. **不确定性**: 添加传感器噪声或错误
5. **多代理**: 多个代理协作探索

## 注意事项

- 程序使用完美迷宫（保证有解）
- 部分可观察性不影响解的存在性，只影响探索效率
- 探索的单元格数量取决于迷宫结构和DFS的路径选择
- 某些区域可能永远不会被探索（如果不在搜索路径上）

## 依赖项

- .NET SDK (推荐 .NET 6.0 或更高版本)
- 无外部依赖

## 作者说明

本实现完全满足任务要求：
✓ 基于DFS的迷宫求解器
✓ 部分可观察性（只能看到相邻单元格）
✓ 逐步构建地图
✓ 战争迷雾机制
✓ 仅使用已发现信息进行决策
✓ 动态更新内部地图
✓ 可视化显示探索过程
✓ 使用DFS逻辑在受限视野下找到终点
